#include "App.h"

App::App()
{
}

App::~App()
{
	writeFile();
}

int App::GetCommand(int maxCommand)
{
	while (true)
	{
		int command;
		cout << "▶ : ";
		cin >> command;

		if (cin.fail())
		{
			cout << "│올바르지 않은 입력입니다" << endl;
			cin.clear();
			cin.ignore(256, '\n'); // cin시 오류잡아주는 코드 
		}
		else
		{
			if (command <= maxCommand && command >= 0)
			{
				return command;
			}
			else
			{
				cout << "│올바르지 않은 입력입니다" << endl;
			}
		}
	}
	cout << "─────────────────" << endl;
}

void App::run()
{
	while (1)
	{
		cout << "┌───────────────┐" << endl;
		cout << "│                              │" << endl;
		cout << "│     ▶   DDoseogwan   ◀     │" << endl;
		cout << "│                              │" << endl;
		cout << "└───────────────┘" << endl;
		cout << "─────────────────" << endl;
		cout << "파일 읽기 모드 설정" << endl;
		cout << "1. Binary 모드" << endl;
		cout << "2. Text 모드" << endl;
		cout << "0. 프로그램 종료" << endl;
		cout << "─────────────────" << endl;
		int num = GetCommand(2);
		if (num == 0)
		{
			return;
		}
		else
		{
			readFile(num);
			login();
		}
	}
}

void App::startmenu()
{
	while (1)
	{
		system("cls");
		cout << "┌───────────────┐" << endl;
		cout << "│                              │" << endl;
		cout << "│     ▶   DDoseogwan   ◀     │" << endl;
		cout << "│                              │" << endl;
		cout << "└───────────────┘" << endl;
		cout << "─────────────────" << endl;
		cout << "▷" << loginedUser->getname() << "님 환영합니다!" << endl;
		cout << "─────────────────" << endl;
		cout << "1. 도서 검색 및 대여" << endl;
		cout << "2. 도서 반납" << endl;
		cout << "0. 뒤로 가기" << endl;
		cout << "─────────────────" << endl;
		int num = GetCommand(2);
		cout << "─────────────────" << endl;
		switch (num)
		{
		case 1:
			searchBook();
			break;
		case 2:
			returnBook();
			break;
		case 0:
			loginedUser = nullptr;
			cout << "자동 로그아웃 되었습니다" << endl;
			cout << "─────────────────" << endl;
			system("pause");
			system("cls");
			return;
		}
	}
}

void App::login()
{
	int id;
	string pw;

	cout << "┌아이디를 입력하세요 : ";
	cin >> id;
	cout << "└비밀번호를 입력하세요 : ";
	cin >> pw;
	for (int i = 0; i < userList.size(); i++)
	{
		if (id == userList[i]->getid())
		{
			if (pw == userList[i]->getpw())
			{
				loginedUser = userList[i];
				system("pause");
				startmenu();
				return;
			}
			else
			{
				cout << "비밀번호가 일치하지 않습니다" << endl;
				system("pause");
				system("cls");
				return;
			}
		}
	}
	cout << "일치하는 아이디가 없습니다" << endl;
	system("pause");
	system("cls");
	return;
}

void App::readFile(int num)
{
	switch (num)
	{
	case 1:
		fr = new BinaryReader();
		fr->readUserFile(&userList);
		fr->readBookFile(&bookList);
		break;
	case 2:
		fr = new TextReader();
		fr->readUserFile(&userList);
		fr->readBookFile(&bookList);
		break;
	}
}

void App::writeFile()
// UserT,UserB,BookT는 아예 첨부터 다시 써주고
// BookB만 바뀔때마다 써주면 된다!
{
	ofstream ofs("UserText.txt");
	for (int i = 0; i < (int)userList.size(); i++)
	{
		ofs << userList[i]->getid() << "\t";
		ofs << userList[i]->getpw() << "\t";
		ofs << userList[i]->getname() << "\t";
		ofs << userList[i]->GetborrowingList().size();
		for (int j = 0; j < userList[i]->GetborrowingList().size(); j++)
		{
			ofs << "\t" << userList[i]->GetborrowingList()[j];
		}
		if (i != (int)userList.size() - 1)
		{
			ofs << endl;
		}
	}
	ofs.close();
	// Write UserText

	ofstream ofs2("UserBinary.dat", ios::binary | ios::out);
	for (int i = 0; i < userList.size(); i++)
	{
		int id = userList[i]->getid();
		int p_len = userList[i]->getpw().size();
		int n_len = userList[i]->getname().size();
		int borrowed_num = userList[i]->GetborrowingList().size();
		string pw = userList[i]->getpw();
		string name = userList[i]->getname();

		ofs2.write((char*)&id, sizeof(int)); // 아이디
		ofs2.write((char*)&p_len, sizeof(int)); // 비밀번호 길이
		ofs2.write(pw.c_str(), p_len); // 비밀번호
		ofs2.write((char*)&n_len, sizeof(int)); // 이름 길이
		ofs2.write(name.c_str(), n_len); // 이름
		ofs2.write((char*)&borrowed_num, sizeof(int)); // 대여한 책의 수
		for (int j = 0; j < borrowed_num; j++)
		{
			int borrowedID = userList[i]->GetborrowingList()[j];
			ofs2.write((char*)&borrowedID, sizeof(int));
		}
	}
	ofs2.close();
	// Write UserBinary

	ofstream ofs3("BookText.txt");
	for (int i = 0; i < bookList.size(); i++)
	{
		ofs3 << bookList[i]->Getbookid() << "\t";
		ofs3 << bookList[i]->Getname() << "\t";
		ofs3 << bookList[i]->Getauthor() << "\t";
		ofs3 << bookList[i]->Getyear() << "\t";
		ofs3 << bookList[i]->Getisborrowed();
		if (bookList[i]->Getisborrowed() == true)
		{
			ofs3 << "\t" << bookList[i]->GetborrwedID();
		}
		// 대여자가 있는 경우
		if (i != (int)bookList.size() - 1)
		{
			ofs3 << endl;
		}
		// 대여자가 없으면 대여자 ID는 저장하지 않는다.
	}
	ofs3.close();
	// Write BookText
}

void App::searchBook()
{
	buildIndex();
	string key;
	cout << "도서명을 입력해 주세요" << endl;
	cout << "▶ : ";
	cin >> key;
	cout << "─────────────────" << endl;
	vector<Book*> tempResult1;
	tempResult1 = (sa->search(key)); // 책 이름으로 검색 결과
	if (tempResult1.size() == 0)
	{
		cout << "찾는 도서가 없습니다." << endl;
		cout << "─────────────────" << endl;
		return;
	}

	string author;
	int year;
	vector<Book*> tempResult2; // 저자명으로 추가 검색
	vector<Book*> finalResult; // 출판년도로 추가 검색
	
	cout << "저자명을 입력해 주세요" << endl;
	cout << "▶ : ";
	cin >> author;
	cout << "─────────────────" << endl;
	for (int i = 0; i < tempResult1.size(); i++)
	{
		if (author == tempResult1.at(i)->Getauthor())
		{
			tempResult2.push_back(tempResult1.at(i));
		}
	}
	// 저자명 검색

	cout << "출판년도를 입력해 주세요" << endl;
	cout << "▶ : ";
	cin >> year;
	cout << "─────────────────" << endl;
	for (int i = 0; i < tempResult2.size(); i++)
	{
		if (year == tempResult2.at(i)->Getyear())
		{
			finalResult.push_back(tempResult2.at(i));
		}
	}
	// 출판년도 검색
	if (finalResult.size() != 0)
	{
		cout << "─────찾은 도서 목록─────" << endl;
	}
	while (1)
	{
		for (int i = 0; i < finalResult.size(); i++)
		{
			cout << i+1 << ". ";
			cout << "도서명: " << finalResult.at(i)->Getname() << endl;
			cout << "   저자명: " << finalResult.at(i)->Getauthor() << endl;
			cout << "   출판 연도: " << finalResult.at(i)->Getyear() << endl;
		}
		cout << "─────────────────" << endl;
		cout << "1. 도서 대여" << endl;
		cout << "0. 뒤로 가기" << endl;
		int cmd1 = GetCommand(1);
		switch (cmd1)
		{
		case 1:
			borrowBook(finalResult);
			finalResult.clear();
			return;
		case 0:
			return;
		}
	}
}

void App::borrowBook(vector<Book*> searchbook)
{
	// 파라미터의 searchbook은 search 함수의 최종결과로 나온 리스트를 담고오는 벡터
	system("pause");
	system("cls");
	cout << "┌───────────────┐" << endl;
	cout << "│                              │" << endl;
	cout << "│     ▶   도서 대여    ◀     │" << endl;
	cout << "│                              │" << endl;
	cout << "└───────────────┘" << endl;
	cout << "─────────────────" << endl;
	cout << "대여할 도서를 선택하세요" << endl;
	for (int i = 0; i < searchbook.size(); i++)
	{
		cout << i+1 << ". ";
		cout << "도서명: " << searchbook[i]->Getname() << endl;
		cout << "   저자명: " << searchbook[i]->Getauthor() << endl;
		cout << "   출판 연도: " << searchbook[i]->Getyear() << endl;
	}
	int num = GetCommand(searchbook.size()) -1;
	if (searchbook[num]->Getisborrowed() == true)
	{
		cout << "이미 대여된 책 입니다" << endl;
		cout << "─────────────────" << endl;
		return;
	}
	else if (loginedUser->GetborrowingList().size() > 5)
	{
		cout << "더 이상 대여할 수 없습니다" << endl;
		cout << "─────────────────" << endl;
		return;
	}
	/// Bookbinary Code
	fstream fs("BookBinary.dat", ios::binary | ios::in | ios::out); // 바이너리/읽기/쓰기
	int BookID;
	int BNameLength;
	int AuthorLength;
	bool Borrow = true; // 대여
	int BorrowID = loginedUser->getid(); // 대여자 id
	for (int i = 0; i < bookList.size(); i++)
	{
		fs.read((char*)&BookID, sizeof(int)); // 책의 아이디를 읽어옴(대여할 책과 비교하기 위함)
		fs.read((char*)&BNameLength, sizeof(int)); // 책 이름 길이만큼 읽어서
		fs.seekg(BNameLength, ios::cur); // seekg함수로 건너뜀 (책 이름은 BNameLength만큼의 길이이며, 한문자는 char에 해당하므로 1byte이다. 따라서 *1 해주는것과 같다)
		fs.read((char*)&AuthorLength, sizeof(int)); // 저자 이름 길이 읽어서
		fs.seekg(AuthorLength + sizeof(int), ios::cur); // 저자이름+출판연도 건너뜀

		if (BookID == searchbook[num]->Getbookid())
			// 대여할 책에 해당
			// 현재위치에 대여여부와 대여자 아이디 덮어쓴다!
		{
			fs.write((char*)&Borrow, sizeof(bool)); // 대여했다 : true를 쓴다
			fs.write((char*)&BorrowID, sizeof(int)); // 대여자 아이디 : 로그인한 유저의 ID를 쓴다
		}
		else
		{
			fs.seekg(sizeof(bool) + sizeof(int), ios::cur);
			// 찾던 도서가 아닐 경우 대여여부(bool) + 대여자아이디(int) 건너뜀
		}
	}

	for (int j = 0; j < bookList.size(); j++)
	{
		if (bookList[j]->Getbookid() == searchbook[num]->Getbookid()) // 원래 bookList에서 정보를 수정하기 위해 searchbook과 대조하여 원본을 찾는다.
		{
			loginedUser->setborrowingList(bookList[j]->Getbookid());
			bookList[j]->SetBorrowed(true);
			bookList[j]->SetBorrowerID(loginedUser->getid());
			// 책의 데이터 수정
		}
	}
	cout << "책 대여가 완료되었습니다." << endl;
	cout << "─────────────────" << endl;
	system("pause");

	return;
}

void App::returnBook()
{
	vector<Book*> BorrowedBook; // 로그인한 유저의 대여목록을 담는 임시 벡터
	for (int i = 0; i < bookList.size(); i++)
	{
		for (int j = 0; j < loginedUser->GetborrowingList().size(); j++)
		{
  			if (loginedUser->GetborrowingList()[j] == bookList[i]->Getbookid())
			{
				BorrowedBook.push_back(bookList[i]);
			}
		}
	}
	system("pause");
	system("cls");
	cout << "┌───────────────┐" << endl;
	cout << "│                              │" << endl;
	cout << "│     ▶   도서 반납    ◀     │" << endl;
	cout << "│                              │" << endl;
	cout << "└───────────────┘" << endl;
	cout << "─────────────────" << endl;
	if (BorrowedBook.size() == 0)
	{
		cout << "반납할 도서가 없습니다" << endl;
		cout << "─────────────────" << endl;
		return;
	}
	cout <<"───" << loginedUser->getname() << "님의 대여목록───" << endl;
	for (int i = 0; i < BorrowedBook.size(); i++)
	{
		cout << i + 1 << ". ";
		cout << "책 이름: " << BorrowedBook.at(i)->Getname() << endl;
		cout << "저자명: " << BorrowedBook.at(i)->Getauthor() << endl;
		cout << "출판 연도: " << BorrowedBook.at(i)->Getyear() << endl << endl;
		// 책의 데이터 출력
	}
	cout << "─────────────────" << endl;
	cout << "반납할 도서를 선택하세요" << endl;
	int num = GetCommand(BorrowedBook.size()) - 1;

	/// bookList에서 해당 도서의 레코드 수정
	vector<int> list = loginedUser->GetborrowingList();
	for (int i = 0; i < bookList.size(); i++)
	{
		if (bookList[i]->Getbookid() == BorrowedBook[num]->Getbookid())
		{
			// 반납할 책을 찾았다!
			for (int j = 0; j < loginedUser->GetborrowingList().size(); j++)
			{
				if (loginedUser->GetborrowingList()[j] == bookList[i]->Getbookid())
				{
					list.erase(list.begin() + j);
					loginedUser->ResetBorrowingList(list);
					//loginedUser->GetborrowingList().erase(loginedUser->GetborrowingList().begin() + j); // 에러가 나는 이유??
				}
				// 대여목록에서 지우고
			}
			bookList[i]->SetBorrowed(false);
			bookList[i]->SetBorrowerID(-1);
		 	// 책의 데이터를 수정한다.
		}
	}

	/// Bookbinary Code
	fstream fs("BookBinary.dat", ios::binary | ios::in | ios::out); // 바이너리/읽기/쓰기
	int BookID;
	int BNameLength;
	int AuthorLength;
	bool returned = false;
	int returnedID = -1;
	for (int i = 0; i < bookList.size(); i++)
	{
		fs.read((char*)&BookID, sizeof(int));
		fs.read((char*)&BNameLength, sizeof(int)); // 책 이름 길이만큼 읽어서
		fs.seekg(BNameLength, ios::cur); // seekg함수로 건너뜀
		fs.read((char*)&AuthorLength, sizeof(int)); // 저자 이름 길이 읽어서
		fs.seekg(AuthorLength + sizeof(int), ios::cur); // 저자이름+출판연도 건너뜀

														/// 디버그해서 read 함수써도 curpointer가 이동하는지 확인
		if (BookID == BorrowedBook[num]->Getbookid())
			// 반납에 해당하는 경우임
			// 현재위치에 대여여부와 대여자 아이디 덮어쓴다!
		{
			fs.write((char*)&returned, sizeof(bool));
			fs.write((char*)&returnedID, sizeof(int));
		}
		else
		{
			fs.seekg(sizeof(bool) + sizeof(int), ios::cur);
			// 찾던 도서가 아닐 경우 대여여부(bool) + 대여자아이디(int) 건너뜀
		}
	}

	cout << "도서 반납을 완료하였습니다." << endl;
	cout << "─────────────────" << endl;
	system("pause");
}

void App::buildIndex()
{
	cout << "1. Binary Search Tree" << endl;
	cout << "2. Hash" << endl;
	cout << "3. Binary Search" << endl;
	int command = GetCommand(3);

	switch (command)
	{
	case 1:
		system("cls");
		cout << "┌───────────────┐" << endl;
		cout << "│                              │" << endl;
		cout << "│   ▶ Binary Search Tree ◀   │" << endl;
		cout << "│                              │" << endl;
		cout << "└───────────────┘" << endl;
		cout << "─────────────────" << endl;
		sa = new BST(&bookList);
		((BST*)sa)->buildIndex();
		break;
	case 2:
		system("cls");
		cout << "┌───────────────┐" << endl;
		cout << "│                              │" << endl;
		cout << "│          ▶ Hash ◀          │" << endl;
		cout << "│                              │" << endl;
		cout << "└───────────────┘" << endl;
		cout << "─────────────────" << endl;
		sa = new Hash(&bookList);
		((Hash*)sa)->buildIndex();
		break;
	case 3:
		system("cls");
		cout << "┌───────────────┐" << endl;
		cout << "│                              │" << endl;
		cout << "│     ▶  Binary Search ◀     │" << endl;
		cout << "│                              │" << endl;
		cout << "└───────────────┘" << endl;
		cout << "─────────────────" << endl;
		sa = new BinarySearch(&bookList);
		break;
	}
}